def r(t):
  return t*np.pi/180.

def fs(x, a):
    a00 = a[0]
    a11 = a[1]
    a12 = a[2]
    a13 = a[3]
    a21 = a[4]
    a22 = a[5]
    a23 = a[6]
    t1 = a11 / (1. + np.exp(a12 * (x - a13)))
    t2 = a21 / (1. + np.exp(a22 * (x - a23)))
    fs = (t1 + t2) / a00
    return fs

def fa(theta1, theta2, aa):
    del_fs = 0. # TODO
    fs1 = fs(theta1 / np.pi, aa)
    fs2 = fs(theta2 / np.pi, aa)
    fa = fs1 + ((np.pi - theta2) / np.pi) * fs2 - del_fs
    return fa

def pfa(aa, ax):
  theta1 = np.linspace(120, 360, 40)
  theta2 = np.linspace(0, 180, 40)
  #fig = plt.figure()
  #ax = plt.gca()
  x = []
  y = []
  z = []
  for t1 in theta1:
    for t2 in theta2:
      constraint1 = t2 > (180. - 0.5 * t1)
      constraint2 = t2 < t1
      constraint3 = t2 < (360. - t1)
      if constraint1 and constraint2 and constraint3:
        c = fa(r(t1), r(t2), aa)
        #c = fa(t1, t2, aa)
        x.append(t2)
        y.append(t1)
        z.append(c)
  z = z - np.min(z)
  z = z / np.max(z)
  for i in range(len(z)):
    ax.scatter(x[i], y[i], c=z[i]*np.ones(3))
  #plt.show()

def _pfa(aa):
  theta1 = np.linspace(120, 360, 40)
  theta2 = np.linspace(0, 180, 40)
  fig = plt.figure()
  ax = plt.gca()
  x = []
  y = []
  z = []
  for t1 in theta1:
    for t2 in theta2:
      constraint1 = t2 > (180. - 0.5 * t1)
      constraint2 = t2 < t1
      constraint3 = t2 < (360. - t1)
      if constraint1 and constraint2 and constraint3:
        c = fa(r(t1), r(t2), aa)
        #c = fa(t1, t2, aa)
        x.append(t2)
        y.append(t1)
        z.append(c)
  z = z - np.min(z)
  z = z / np.max(z)
  ax.scatter(x, y, c=z, s=10, cmap='jet')
  #for i in range(len(z)):
    #ax.scatter(x[i], y[i], c=z[i]*np.ones(3))
  plt.show()

def paa(i, j, n):
  aa = [1., 1., 4., 1., -2., 0.1, 0.1]
  aai = np.logspace(-6,6,n)#*np.pi/180.
  aaj = np.logspace(-6,6,n)#*np.pi/180.
  fig = plt.figure()
  for q in range(n):
    aa[i] = aai[q]
    for r in range(n):
      aa[j] = aaj[r]
      print(q*n+r+1)
      print(aa)
      ax = fig.add_subplot(n, n, q*n+r+1)
      pfa(aa, ax)
  plt.show()



Data I want saved:
- Time
- Balloon position
- True wind velocity
- Estimated wind velocity
- Uncertainty in estimated wind velocity
- Whether we are sampling or not
- Whether we are planning nominally or not
- Control effort (ascent rate)

Plots I want to make:
- Average distance over time
- Average velocity quality over time
- Average planning cost over time
- Total number of samples over time
- Uncertainty in position over time
- Fuel usage over time


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SIMULATION STRUCTURE
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

LoonSim
  Environment (NOAA Field)
    Field
      origin
      lat_span_m
      lon_span_m
      hrs_ahead
      min_lat
      max_lat
      min_lon
      max_lon
      data
      field
      coords
      model_vnorth
      model_veast
      pmin
      pmax

      __init__()
      __str__()
      __find__()
      __check_validity__()

      get_flow()
      set_flow()

    __init__()

    get_flow()

  PathPlanner (MPC Fast)
    off_nominal
    vx_estimator
    vy_estimator
    jets
    delta_p
    delta_std
    jets_expectation
    delta_p_expectation
    delta_std_expectation
    lowest_J_yet
    backedges
    leaves
    curr_key
    nodes_expanded
    streamres
    streammax
    streammin
    threshold
    streamsize
    lower
    upper
    sampled_ponts
    alts_to_sample
    FieldEstimator (1D GPFE)
      estimators
      prediction_key
      X
      y
      recently_sampled_X
      recently_sampled_y
      expiring_X
      expiring_y

      __init__()
      __reset__()
      __build_data__()
      __restrict__()
      __partition__()

      fit()
      predict()
      changing_estimators()
      add_data()

    add_sample()    // Stage sampled data for adding to estimators
    train()         // Train estimators for the first time
    retrain()       // Retrain estimators
    predict()       // Return prediction with standard deviation
    ev()            //** Return prediction without standard deviation
    plan()          // Plan wrapper
    plot()          // Plotting code

    __init__()                          //* Initialization
    __accel__()                         //* Calculate acceleration towards origin in particular jetstream
    __accel_cost__()                    //* Calculate acceleration cost term (norm of acceleration)
    __best_pol__()                      // Find lowest cost policy (does not find associated costs)
    __cost_to_altitude__()              // Calculates change in position from current altitude to another altitude
    __delta_p_between_jetstreams__()    // Calculates change in position between each jetstream pair
    __desired_dir__()                   //* Calculates direction to origin
    __drag_force__()                    //** Calculates quadratic drag force
    __find_altitudes_for_sampling__()   //* Finds places that would be useful to sample
    __find_best_jetstream__()           // Finds lowest cost jetstream to travel to (no use of tabulated values)
    __get_stay_branch_length__()        // Calculates how long to stay put (for planning purposes)
    __incorporate_samples__()           // Add the data we've sampled to our estimators
    __parse_field__()                   // Extracts data from Field object
    __local_max_idx__()                 // Finds local maxima in
    __min_climb__()                     //* Finds closest of several equally desirable jetstreams
    __min_leaf__()                      // Finds leaf on minimum cost branch
    __min_leaf_J__()                    // Finds cost of minimum cost branch
    __moving_towards_target__()         // Finds whether we are (generally) moving towards the origin
    __phiddot__()                       // Finds acceleration towards origin
    __pol__()                           // Finds policy associated with a particular leaf
    __reset__()                         //* Make yourself ready for a new plan (move into Monte Carlo at least)
    __redo_jetstreams__()               // Rerun the jetstream identifier
    __redo_jetstreams_etc__()           // Redo jetstreams and re-calculate changes in position between them
    __reset_plan__()                    // Make yourself ready for a new plan
    __sample_destination__()            // Find best spot in target region to sample
    __smooth__()                        //* Smooths noisy data
    __tree_search__()                   //** Deprecated tree search
    __tree_search_w_std__()             // Tree search
    __wind_dir__()                      //* Finds direction of wind at a certain altitude
    __hacky_way_to_avoid_bug_when_not_in_jetstream__()

  Loon

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MAIN FILE
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main()
local
